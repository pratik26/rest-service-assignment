/**
 * 
 */
package com.example.strategy;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveTask;
import java.util.concurrent.TimeUnit;
import java.util.stream.LongStream;

import com.example.helper.PrimeNumberHelper;



/**
 * This strategy class uses fork-join methodology and  variant of the classic O(sqrt(N)) algorithm  to determine a given number is prime or not .
 * Algorithm:
 * (1) Iterate over the range ( 2, limit ) in parallel and check if each number is prime or composite
 * (2) If its prime, add to the result
 * The complexity is O(n*sqrt(n))
 * @author Pratik
 */
public class ForkJoinAndOptimisedPrimeCheckPrimeRangeGenStrategy implements IPrimeRangeGeneratorStrategy 
{

	/* (non-Javadoc)
	 * @see example.strategy.IPrimeRangeGeneratorStrategy#getPrimeNumbers(long)
	 */
	@Override
	public List<Long> getPrimeNumbers(long limit) 
	{
		ForkJoinPool pool = new ForkJoinPool();
        
        PrimeNumberGenerator generator = new ForkJoinAndOptimisedPrimeCheckPrimeRangeGenStrategy.PrimeNumberGenerator(2, limit);
        
        //Execute the three tasks in the pool using the execute() method.
        pool.execute(generator);
        
        //Write to the console information about the status of the pool every second 
        //until the task has finished their execution.
        do
        {
           //System.out.printf("******************************************\n");
           //System.out.printf("Parallelism: %d\n", pool.getParallelism());
           //System.out.printf("Active Threads: %d\n", pool.getActiveThreadCount());
           //System.out.printf("Task Count: %d\n", pool.getQueuedTaskCount());
           //System.out.printf("******************************************\n");
           try
           {
              TimeUnit.SECONDS.sleep(1);
           } catch (InterruptedException e)
           {
              e.printStackTrace();
           }
        } while ((!generator.isDone()));
        //Shut down ForkJoinPool using the shutdown() method.
        pool.shutdown();
        //Write the number of results generated by each task to the console.
        List<Long> results = generator.join();
        return results;
    }
	
	/**
	 * 
	 * Task Class to generate prime list range using divide-conquer technique
	 * @author Pratik
	 * 
	 */
	static class PrimeNumberGenerator extends RecursiveTask<List<Long>>
	{
	   private static final long serialVersionUID = 1L;
	   /**
	    * This number is set to a specific value right now.
	    * But, this number would be computed by doing test runs and analysis.
	    */
	   private static final long THRESHOLD = 500000L;
	   
	   private final long      start;
	   private final long      end;
	 
	   public PrimeNumberGenerator(long start, long end)
	   {
	      this.start = start;
	      this.end = end;
	   }
	 
	   @Override
	   protected List<Long> compute()
	   {
		  System.out.println("PrimeNumberGenerator - " + start + " " + end);
		  
	      List<Long> list = new ArrayList<Long>();
	      
	      if (start >= end)
	      {
	    	  return list;
	      }
	      
	      List<PrimeNumberGenerator> tasks = new ArrayList<PrimeNumberGenerator>();
	      
	      long difference = end - start;
	      if ( difference > THRESHOLD)
	      {
	    	  PrimeNumberGenerator task = new PrimeNumberGenerator(start,(start +end)/2);
	    	  task.fork();
              tasks.add(task);
              
              task = new PrimeNumberGenerator((start +end)/2 + 1,end);
	    	  task.fork();
              tasks.add(task);
	      }
	      else
	      {
	    	  list = LongStream.range(start, end).filter(PrimeNumberHelper::isPrime).collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
	    	  
	      }
	      //add to the result, the results returned by the subtasks launched by this task.
	      addResultsFromTasks(list, tasks);
	      
	      System.out.println("PrimeNumberGenerator complete - " + start + " " + end);
	      //Return the list of prime numbers
	      return list;
	   }
	 
	   //For each task stored in the list of tasks, call the join() method that will wait for its finalization and then will return the result of the task. 
	   //Add that result to the list of prime numbers using the addAll() method.
	   private void addResultsFromTasks(List<Long> list, List<PrimeNumberGenerator> tasks)
	   {
	      for (PrimeNumberGenerator item : tasks)
	      {
	         list.addAll(item.join());
	      }
	   }
	   
	   
	}
}
